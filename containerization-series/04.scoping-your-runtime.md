# Containerizing IBM ACE: A Blog Series - Scoping your runtimes

## 1. Performance and startup

Big schemas mean big compile and load times. Treat these as heavy hitters. Measure compile time and cold start so you know the real cost.

Build and compile at artifact build time where possible. Faster pod starts, fewer surprises.

Track startup times in a test or uat setup. Set a budget for cold starts and alert when you exceed it.

## 2. Resource interference

Do not put two applications that have nothing to do with each other in the same container. If one goes wild on CPU or memory, the other suffers.

Aim for a clean noisy neighbor boundary. If you cannot explain why two resources share limits, split them.

## 3. Bundling logic

Bundle together when at least one of these is true:

- Same endpoint or interface and same criticality.

- Same owner or operational responsibility. One team, one runtime is easy to live with.

- Small number of resources that share the same library and are updated together.

- Part of a bigger tightly coupled setup

Avoid bundling when any of these are true:

- You plan to scale them differently.

- They have different criticality. Do not mix a payment flow with a reporting job.

- They handle data with different sensitivity levels.

- They are only loosely coupled and can fail independently.

## 4. Libraries and shared code

If several tiny resources reuse the same library and you always upgrade them together, they can live together.

If a library update should not affect all resources at once, separate them to reduce the blast radius.

Dare to split up your libraries. If 50% of your flows use library subflow A and 50% user library subflow 5, convert this into
2 seperate libs

## 5. Scaling strategy

If something must scale out, do not package it with something that does not.

Prefer one scaling unit per runtime. It keeps autoscaling rules simple and predictable.

## 6. Security and data sensitivity

Group resources with similar sensitivity and trust level.

Do not bundle a sensitive flow with a less secure one if that weakens the overall posture or complicates audits.

## 7. Ownership and operations

Group by support boundary. If the on call or deployment cadence is different, split.

Align runtime boundaries with who deploys, who monitors, and who fixes.

## 8. Coupling level

End to end chains that are tightly coupled and must move together can be grouped.

Loosely coupled pieces should not share a runtime. Independent failure is a feature, not a bug.

## 9. Build and release shape

Compile at build time. Keep runtime work minimal.

If you use fry, verify that the artifact that passed tests is the one you deploy.

If you use bake, you are wrong.

## 10. A few more worth adding

Licensing cost: more CPU usually means more PVU and more money. Include licensing in your scaling plan.

Observability and blast radius: if a runtime fails, which services and dashboards are down. Keep failure domains small.

Configuration variance: if two apps need very different config or secrets, it is a hint to split.

Upgrade cadence: if one piece changes weekly and another quarterly, consider separate runtimes.